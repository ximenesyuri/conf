# SHEBANG
snippet #! "shebang"
#! /bin/bash
endsnippet

# INCLUDES
snippet src
source
endsnippet

snippet bsrc
source \${BASH_SOURCE%/*}/$0
endsnippet

snippet bs
\${BASH_SOURCE[@]}
endsnippet

snippet bl
\${BASH_LINENO[@]}
endsnippet

# VARIABLES
snippet 1
"\$1"
endsnippet

snippet 2
"\$2"
endsnippet

snippet 3
"\$3"
endsnippet

snippet 4
"\$4"
endsnippet

snippet 5
"\$5"
endsnippet

snippet /@/ "" r
"\$@"
endsnippet

snippet @1
"\${@:1}"
endsnippet

snippet @2
"\${@:2}"
endsnippet

snippet @3
"\${@:3}"
endsnippet

snippet @4
"\${@:4}"
endsnippet

snippet @5
"\${@:5}"
endsnippet

snippet ?
"\$?"
endsnippet

# FUNCTION
snippet fun "function"
function ${1:name}(){
    ${0:statement}
}
endsnippet

snippet func "function"
function ${1:name}(){
    ${0:statement}
}
endsnippet

snippet function "function"
function ${1:name}(){
    ${0:statement}
}
endsnippet

# ARRAY
snippet $[ "def array"
${1:array}=[${2:element}]
endsnippet

snippet ${ "call array"
${${1:name}[${2:index}]}
endsnippet

snippet $! "call array" 
${!$0[@]}
endsnippet

snippet [* "call array"
${$0[*]}
endsnippet

snippet [@ "call array"
${$0[@]}
endsnippet

snippet [i "call array"
${$0[$i]}
endsnippet

# DECLARE
snippet df "declare function"
declare -f $0
endsnippet

snippet da "declare array"
declare -a $0
endsnippet

snippet dA "declare associative array"
declare -A $0
endsnippet

# UNSET
snippet uns
unset ${1:data}
endsnippet

snippet unsa
unset -a ${1:data}
endsnippet

snippet unsA
unset -A ${1:data}
endsnippet

snippet unsf
unset -f ${1:data}
endsnippet

# IF
snippet if
if [[ "\$${1:var}" == "${2:cond}" ]]; then
    ${0:statement}
fi
endsnippet

snippet ifz
if [[ -z "${1:var}" ]]; then
    ${0:statement}
fi
endsnippet

snippet iff
if [[ -f "${1:file}" ]]; then
    ${0:statement}
fi
endsnippet

snippet ifd
if [[ -d "${1:dir}"  ]]; then
    ${0:statement}
fi
endsnippet

snippet ifx
if [[ -x "${1:cmd}" ]]; then
    ${0:statement}
fi
endsnippet

snippet if?
if [[ ! "\$?" == "0" ]]; then
    return 1
fi
endsnippet

snippet if|
if [[ "${1:var}" == "${2:cond}" ]] ||
   $0   
    return 1
fi
endsnippet

snippet if!f
if [[ ! -f "${1:file}" ]]; then
    ${0:statement}
fi
endsnippet

snippet if!d
if [[ ! -d "${1:dir}"  ]]; then
    ${0:statement}
fi
endsnippet

snippet if!x
if [[ ! -x "${1:cmd}" ]]; then
    ${0:statement}
fi
endsnippet

snippet elif
elif [[ "\$${1:var}" == "${2:cond}" ]]; then
    ${0:statement}
endsnippet

snippet eliff
if [[ -f "${1:file}" ]]; then
    ${0:statement}
fi
endsnippet

snippet elifd
if [[ -d "${1:dir}"  ]]; then
    ${0:statement}
fi
endsnippet

snippet elifx
if [[ -x "${1:cmd}" ]]; then
    ${0:statement}
fi
endsnippet

snippet elif|
elif [[ "\$${1:var}" == "${2:cond}" ]] ||
    ${0:statement}
endsnippet

snippet elif!f
if [[ ! -f "${1:file}" ]]; then
    ${0:statement}
fi
endsnippet

snippet elif!d
if [[ ! -d "${1:dir}"  ]]; then
    ${0:statement}
fi
endsnippet

snippet elif!x
if [[ ! -x "${1:cmd}" ]]; then
    ${0:statement}
fi
endsnippet

snippet el
else
endsnippet

## FOR
snippet for
for ${1:var} in ${2:interval}; do
    ${0:statement}
done
endsnippet

## WHILE
snippet wh
while :
do
    ${0:statement}
done
endsnippet

snippet whi
while :
do
    ${0:statement}
done
endsnippet

snippet while
while :
do
    ${0:statement}
done
endsnippet

## CONDITIONALS
snippet [=
[[ "\$${1:var}" == "${2:cond}" ]]
endsnippet

snippet [[
[[ "\$${1:var}" == "${2:cond}" ]]
endsnippet

snippet [[=
[[ "\$${1:var}" == "${2:cond}" ]]
endsnippet

snippet [|
[[ "${1:var}" == "${2:cond}" ]] ||
$0
endsnippet

snippet [[|
[[ "${1:var}" == "${2:cond}" ]] ||
$0
endsnippet

snippet [*
[[ "\$${1:var}" == *"${2:substring}"* ]]
endsnippet

snippet [[*
[[ "\$${1:var}" == *"${2:substring}"* ]]  
endsnippet

snippet [p
[[ "\$${1:var}" =~ "${2:pattern}" ]]
endsnippet

snippet [[p
[[ "\$${1:var}" =~ "${2:pattern}" ]]
endsnippet

snippet [z
[[ -z "\$${1:var}" ]]
endsnippet

snippet [[z
[[ -z "\$${1:cond}" ]]
endsnippet

snippet [n
[[ -n "\$${1:var}" ]]
endsnippet

snippet [[n
[[ -n "\$${1:cond}" ]]
endsnippet

snippet [f
[[ -f "\$${1:var}" ]]
endsnippet

snippet [[f
[[ -f "\$${1:cond}" ]]
endsnippet

snippet [d
[[ -d "\$${1:var}" ]]
endsnippet

snippet [[d
[[ -d "\$${1:cond}" ]]
endsnippet

snippet [x
[[ -x "\$${1:var}" ]]
endsnippet

snippet [[x
[[ -x "\$${1:cond}" ]]
endsnippet

snippet [!x
[[ ! -x "\$${1:cond}" ]]
endsnippet

snippet [!f
[[ ! -f "\$${1:cond}" ]]
endsnippet

snippet [!d
[[ ! -d "\$${1:cond}" ]]
endsnippet

snippet [!
[[ ! "\$${1:var}" == "${2:cond}" ]]
endsnippet

snippet [[!
[[ ! "\$${1:var}" == "${2:cond}" ]]
endsnippet

snippet [?
[[ "\$?" == "${1:cond}" ]]
endsnippet

snippet [[?
[[ "\$?" == "${1:cond}" ]]
endsnippet

# INTERVALS
snippet int
(( i=${1:init}; i<=${2:end}; i++ ))
endsnippet

snippet ((
(( i=${1:init}; i<=${2:end}; i++ ))
endsnippet

snippet {
\{${1:init}..${2:end}\}
endsnippet

# ECHO
snippet ec
echo "${1:text}"
endsnippet

snippet ecn
echo -e -n "${1:text}"
endsnippet
snippet echn
echo -e -n "${1:text}"
endsnippet

snippet echon
echo -e -n "${1:text}"
endsnippet

# SHIFT
snippet sh
shift $0
endsnippet

snippet shi
shift $0
endsnippet

# SORT
snippet sort
sort -V $0
endsnippet

snippet sorta
sorted_array=($(printf "%s\n" "${array[@]}" | sort -V))
endsnippet

# FIND
snippet find
find dir -mindepth n -maxdepth m -type f/d -name "*string*"
endsnippet

snippet finda "find array"
(\$(find dir -mindepth n -maxdepth m -type f/d -name "*string*" -printf '%P\n' | sort -V))
endsnippet

snippet finde "find execute command to each"
find dir -type f/d -name "*string*" -exec command {} \;
endsnippet

# MAPFILE
snippet map
mapfile -t array < <(${1:command})
endsnippet

# READ
snippet read 
read -e -r -p "> " $0
endsnippet

# DEV/NULL
snippet dev
> /dev/null
endsnippet

snippet dev2
> /dev/null 2>&1
endsnippet

# SED
snippet sed
sed "s/${1:entry}/${2:replace}/g" $0
endsnippet

snippet sedd "delete all lines containing a given pattern"
sed -i "/string/d" file.txt
endsnippet

snippet seddb "delete content between lines matching a given pattern"
sed "/$START/,/$END/d" file.txt
endsnippet

snippet sedp
escapedPath=\${${1:path}//\\//\\\\/}
sed "s/\$escapedPath//g" $0
endsnippet

snippet sed-path
escapedPath=\${${1:path}//\\//\\\\/}
sed "s/\$escapedPath//g" $0
endsnippet

snippet seda "append a file with a variable contents below the line that matches a pattern"
sed -i "/pattern/a\\\$variable"  file.txt
endsnippet

snippet sed-append-below
sed -i "/pattern/a\\\$variable"  file.txt
endsnippet

snippet sedf "append a file with contents of another file below the line that matches a pattern"
sed -i "/pattern/r content.txt" file.txt
endsnippet

snippet sed-append-file
sed -i "/pattern/r content.txt" file.txt
endsnippet

snippet sedi "append a file with a variable contents above the line that matches a pattern"
sed -i "/pattern/i\\\$variable " file.txt
endsnippet

snippet sed-append-above
sed -i "/pattern/a\\\$variable" file.txt
endsnippet

# GREP

# AWK

# YQ
snippet yq
\$(yq eval '.root.entry' file.yml)
endsnippet

snippet yqa
(\$(yq eval '.root.entry[]' file.yml))
endsnippet

snippet yqk
(\$(yq eval -o t '.entry | select(type == "!!map") | keys' file.yml)
endsnippet

snippet yqi
yq eval ".root.key += {\"subkey\" : \"value\"}" -i file.yml
endsnippet

snippet yqd
yq eval  '.del(.key.array[] | select(. == "value"))' -i file.yaml
endsnippet

# STRING MANIPULATION
snippet base
${1:basename}=\${${2:path}##*/}
endsnippet

snippet dir
${1:dirname}=\${${2:path}%/*}
endsnippet

snippet basename
${1:basename}=\${${2:path}##*/}
endsnippet

snippet dirname
${1:dirname}=\${${2:path}%/*}
endsnippet

snippet ext
ext=\${${1:file}##*.}
endsnippet

snippet file
${1:filename}=\${${2:file}%.*}
endsnippet

snippet before
\${${1:var}%${2:token}*}
endsnippet

snippet bef
\${${1:var}%${2:token}*}
endsnippet

snippet after
\${${1:var}##*${2:token}}
endsnippet

snippet aft
\${${1:var}##*${2:token}}
endsnippet

snippet esc
espapedString=\$(printf '%q' "string")
escapedString=\${escapedString//\\//\\\\/}
endsnippet

snippet escape
espapedString=\$(printf '%q' "string")
escapedString=\${escapedString//\\//\\\\/}
endsnippet

# ARRAY MANIPULATION
snippet index "get the index of an element in an array"
index=$(printf "%s\n" "\${array[@]}" | grep -n -m 1 "\$element" | awk -F: '{print \$1 - 1}')
endsnippet

# PATH MANIPULATION
snippet root "get root name of a path"
root=$(echo "/path/to/some" | cut -d'/' -f2)
endsnippet

# YES OR NO
snippet yn
while :
do
    read -e -r -p "> " yn
    if [[ "\${yn}" == "yes" ]] || [[ "\${yn}" == "y" ]]; then
	$0
    elif [[ "\${yn}" == "no" ]] || [[ "\${yn}" == "n" ]]; then 
	echo "Aborting..."
	break
    else
	echo "Please, write y/yes or n/no."
	continue
    fi
done
endsnippet

